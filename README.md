# Проект 2: Лабиринты

## Описание

Проект состоит из реализации консольной программы для генерации лабиринтов и поиска пути в них. Программа должна быть способна генерировать лабиринты различной сложности и размеров, а также предоставлять один или несколько методов поиска пути от заданной точки А (начала) к точке Б (конца). Интерфейс приложения должен быть простым и понятным, с возможностью отрисовки в консоли лабиринта и найденного пути.

## Функциональные требования
- Реализация как минимум 2-х алгоритмов для случайной генерации лабиринтов.
- Реализация как минимум 2-х алгоритмов для поиска пути из заданной начальной точки А в конечную точку Б.
- Печать лабиринта в консоль с точками А и Б.
- Отображение пути через лабиринт при его наличии.

## Нефункциональные требования
- Код должен быть написан ясно и структурировано в соответствии с требованиями, указанными в разделе "Требования к ДЗ" информационного блока.
- Программа должна иметь текстовый интерфейс.
- Наличие документации по использованию, а также по алгоритмам генерации и решения лабиринта.

## Требования к ДЗ на scala
- Переменные и функции должны иметь осмысленные названия;
- Тест классы именуются <ClassName>Spec, где <ClassName> - класс к которому пишутся тесты;
- Тест классы находятся в том же пакете, что и класс к которому пишутся тесты (например, класс Fibonacci находится в пакете fibonacci в директории src/main/scala/fibonacci, значит его тест класс FibonacciSpec должен быть в том же пакете в директории src/test/scala/fibonacci);
- Каждый тест должен быть в отдельном test suite;
- Использовать java коллекции запрещается (Используйте Scala коллекции);
- Использовать mutable коллекции запрещается;
- Использовать var запрещается;
- Использование this запрещается (используйте self, если надо);
- Использование return запрещается;
- Использование System.exit запрещается;
- Касты или проверки на типы с помощью методов из Java вроде asInstanceOf запрещаются;
- Использование циклов запрещается (используйте for comprehension, tailRec, методы Monad, fold);
- Использование небезопасных вызовов разрешено только в тестах (например .get у Option);
- Использование взятия и освобождения примитивов синхронизации: semaphore, mutex - из разных потоков запрещено;
- Использование require для ошибок запрещается

## Описание входных и выходных данных
### Ввод
- Параметры размера лабиринта (ширина, высота).
- Настройки алгоритма генерации лабиринта, если необходимы.
- Начальная и конечная точки лабиринта.
### Вывод
- Визуализация сгенерированного лабиринта в консоли.
- Путь от начальной до конечной точки, если таковой был найден, в виде визуализации.

## Инструкции по реализации
- Изучите и реализуйте несколько алгоритмов генерации лабиринтов, например, алгоритмы Прима или Краскала.
- Реализуйте алгоритм поиска пути, например, поиск в ширину (BFS) или А* (A-star).
- Проверьте работоспособность программы с разными параметрами и напишите тесты.
- Разработайте способ отображения лабиринтов и путей в них, используя символьную графику. Можно использовать простые символы (#, *, |, _), можно более сложные (unicode).
- При реализации вам могут пригодиться следующие примитивы (на примере Java):
    ```java
    public interface Generator {
        Maze generate(int height, int width);
    }
    
    public interface Solver {
        List<Coordinate> solve(Maze maze, Coordinate current, Coordinate end);
    }
    
    public interface Renderer {
        String render(Maze maze);
        String render(Maze, maze, List<Coordinate> path);
    }
    
    public final class Maze {
        private final int height;
        private final int width;
        private final Cell[][] grid;
    }
    
    public record Cell(int row, int col, Type type) {
        public enum Type { WALL, PASSAGE }
    }
    
    public record Coordinate(int row, int col) {}
    ```

## Тестирование
- Проверьте, способны ли алгоритмы решения найти путь из заранее известных лабиринтов.
- Удостоверьтесь, что лабиринты корректно отображаются в консоли.
- Напишите тесты на устойчивость к ошибкам в случае неправильных входных данных.

## Ограничения и советы
- Ограничение: алгоритмы требуется реализовать самостоятельно.
- Ограничение: сосредоточьтесь на консольном интерфейсе. Вся визуализация лабиринта и пути должна выполняться с помощью стандартного вывода в консоль, без использования графических интерфейсов.
- Совет: учитывайте размер консоли. Длина и ширина лабиринта должны быть адаптированы к стандартным размерам окна консоли.
- Совет: не усложняйте. Постарайтесь сделать интерфейс пользователя интуитивно понятным, минимизируя количество необходимых шагов для генерации и решения лабиринта.
- Совет: документируйте, что важно. Нужно ясное и конкретное документирование кода, чтобы облегчить его понимание.
- Совет: пишите обобщенный код. У всех генераторов и решателей лабиринта единый контракт.

## Дополнительные материалы
- О генерации лабиринтов: https://habr.com/ru/articles/445378/
- Поиск в глубину: https://ru.algorithmica.org/cs/graph-traversals
- Поиск в ширину: https://ru.algorithmica.org/cs/shortest-paths

## Критерии оценки
За задание можно получить 115 баллов.
- +20 бонусов за реализацию различных типы поверхностей лабиринта и их учёте при построении маршрута, например
    - ухудшающие поверхности: болота, песок и т.п.
    - улучшающие поверхности: монетки, хорошее покрытие и т.п.
- Дополнительно можно получить личные бонусные баллы на усмотрение ассистента. 
- Детали о снятии обычных и начислении бонусных баллов можно найти в разделе "Информационный блок".
